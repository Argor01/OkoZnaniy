# Комплексный анализ проекта OkoZnaniy

## Оглавление
1. [Архитектура и стек](#1-архитектура-и-стек)
2. [Уязвимости и риски безопасности](#2-уязвимости-и-риски-безопасности)
3. [Критичные моменты бизнес-логики](#3-критичные-моменты-бизнес-логики)
4. [Рекомендации по приоритетам](#4-рекомендации-по-приоритетам)

---

## 1. Архитектура и стек

- **Backend:** Django, DRF, SimpleJWT, PostgreSQL/SQLite, Redis, Celery, Channels.
- **Frontend:** React (Vite), axios, React Query.
- **Auth:** JWT (access/refresh), allauth (Google/VK), email/username backend.
- **Роли:** client, expert, arbitrator, admin, partner (модель `User.role`).

---

## 2. Уязвимости и риски безопасности

### 2.1 Критичные

#### IDOR: файлы заказа доступны любому авторизованному пользователю

**Где:** `apps/orders/views.py` — `OrderFileViewSet`.

- `get_queryset()` возвращает все файлы заказа по `order_id`:  
  `OrderFile.objects.filter(order_id=self.kwargs['order_pk'])`.
- Не проверяется, что пользователь — клиент или эксперт этого заказа.
- Любой авторизованный пользователь, зная `order_id` и `file_id`, может скачать файл:  
  `GET /api/orders/orders/{order_id}/files/{file_id}/download/`.

**Рекомендация:** Ограничить выборку: оставить только файлы тех заказов, где `request.user` — `order.client` или `order.expert` (или staff). Например, предварительно получить заказ и проверить участие, затем фильтровать файлы по этому заказу.

---

#### Скачивание файла заказа без токена (401 при открытии ссылки)

**Где:** фронт отдаёт ссылку на `download_url`; пользователь может открыть её в новой вкладке или скопировать.

- Запрос к `download` идёт без заголовка `Authorization`, если ссылка открыта вне SPA.
- Сервер возвращает 401, файл не скачивается.

**Рекомендация:** Не использовать прямую ссылку для скачивания. На фронте: вызов API с токеном (например, `GET download` через `apiClient`), получение blob, создание временной ссылки и программное скачивание. Либо отдельный endpoint с одноразовым токеном в query для скачивания (с коротким TTL и привязкой к user/order).

---

#### Секреты и окружение

- **SECRET_KEY:** берётся из `os.getenv("SECRET_KEY")`. Если в проде переменная не задана, ключ будет `None` — возможны сбои и риски сессий/JWT.
- **ALLOWED_HOSTS:** из env. Пустая строка даёт `['']` — небезопасно для продакшена.
- В `settings.py` закомментирован старый SECRET_KEY — не оставлять в репозитории даже закомментированным.
- Платёжные пароли (ALFABANK_*, SBP_*) в коде как плейсхолдеры — в проде обязаны быть только в env.

**Рекомендация:** В проде всегда задавать SECRET_KEY и ALLOWED_HOSTS; при старте приложения проверять их наличие и выходить с ошибкой, если не заданы.

---

### 2.2 Высокий приоритет

#### CORS

- **Где:** `config/settings.py`
- В DEBUG: `CORS_ALLOW_ALL_ORIGINS = True` — любый origin может ходить к API.
- В production: `CORS_ALLOW_ALL_ORIGINS = False`, но в `CORS_ALLOWED_ORIGINS` указаны в т.ч. IP (например, `45.12.239.226`). Утечка домена/IP в репозитории.

**Рекомендация:** В проде не использовать `CORS_ALLOW_ALL_ORIGINS`; задавать только нужные фронт-домены через env (без хардкода IP в коде).

---

#### CSRF в DEBUG

- В `DEBUG=True` ослаблены настройки CSRF (cookie secure, httponly и т.д.). Для API на JWT это часто допустимо, но если где-то остались cookie-сессии для критичных действий — риск.

**Рекомендация:** Чётко разделять: только JWT для API; если используются cookie-сессии — не отключать CSRF для них и не ослаблять настройки в проде.

---

#### Платёжный callback (process_callback)

- **Где:** `apps/payments/views.py` — `PaymentViewSet.process_callback` (POST по `pk`).
- ViewSet под `permission_classes = [IsAuthenticated]`, `get_queryset()` ограничивает платежи по `order__client=user`.
- Callback от платёжного провайдера обычно идёт без JWT; при текущей схеме запрос от банка получит 401.

**Рекомендация:** Вынести обработку callback в отдельный endpoint (например, `POST /api/payments/callback/`), с `AllowAny`, проверкой подписи/секрета от провайдера и без привязки к текущему пользователю. Текущий `process_callback` по `pk` оставить только для внутренних/тестовых вызовов, если нужно.

---

#### Роль пользователя: непоследовательные проверки

- В части мест используется `user.role` (например, `orders/views.py`: `take_order`, `create_dispute`), в других — `getattr(user, 'role', None)`.
- При отсутствии поля или миграции возможен `AttributeError` в первых случаях.

**Рекомендация:** Везде использовать безопасное получение роли (например, `getattr(user, 'role', None)`) и явно обрабатывать `None` (отказ в доступе или дефолтная роль).

---

### 2.3 Средний приоритет

#### Загрузка файлов (чаты, заказы)

- Размер и расширения проверяются (ALLOWED_EXTENSIONS, MAX_UPLOAD_SIZE).
- Нет проверки содержимого (тип по magic bytes); теоретически возможна загрузка подменённого «документа» с опасным содержимым.

**Рекомендация:** Хранить файлы вне корня раздачи; отдавать через контролируемый view (как сейчас); при необходимости — проверка MIME по содержимому и лимит количества/размера вложений на пользователя.

#### Чат: запрет контактов в тексте

- В модели `Message.clean()` запрещаются подстроки вроде телефонов, @, url. Обход возможен (пробелы, юникод, разбиение).

**Рекомендация:** Считать текущую проверку базовой; при ужесточении политики — нормализация строк и более строгие правила/модерация.

#### JWT и хранение на фронте

- Токен в `localStorage` — уязвим при XSS. Для SPA это распространённая схема, но риск есть.

**Рекомендация:** Строгая санитизация вывода, Content-Security-Policy; при высокой чувствительности — рассмотреть httpOnly cookie для refresh и короткоживущий access в памяти.

---

## 3. Критичные моменты бизнес-логики

### 3.1 Заказы и статусы

- Переходы статусов разбросаны по разным action (`approve`, `revision`, `submit`, `complete`, `take` и т.д.). Нет единой машины состояний (например, явной матрицы «кто и из какого статуса может перевести в какой»).
- **take_order** (стр. ~273): проверяется `order.status == 'new'`, но в других местах есть переходы из `waiting_payment`, `revision` — возможна рассинхронизация, если где-то забыли обновить условие.
- **complete_order** (стр. ~297): переводит заказ в `completed` без проверки оплаты. Если в системе есть сценарий «сначала оплата, потом завершение», возможен переход в «выполнен» до фактической оплаты.

**Рекомендация:** Вынести переходы статусов в один слой (сервис/машина состояний) с явной матрицей (текущий статус, роль, целевой статус) и единой точкой вызова.

---

### 3.2 Скидки на заказ

- **Где:** `OrderViewSet.apply_discount`, `remove_discount`.
- Нет явной проверки роли: любой, кто может вызвать `get_object()` для заказа (клиент, эксперт, staff), может применить или снять скидку.
- Эксперт может менять скидку по заказу клиента — вопрос политики (часто скидку должен менять только клиент или система).

**Рекомендация:** Явно ограничить вызов: например, только `order.client == request.user` или staff; при необходимости — только до определённого статуса (например, до «в работе»).

---

### 3.3 Деньги и балансы

- В коде встречаются фиксированные коэффициенты (например, 70% эксперту, 30% платформе) в `director/views.py`. Желательно вынести в настройки/константы и учитывать при расчётах выплат.
- Баланс и frozen_balance в модели User; списание/начисление должны быть атомарными (select_for_update или транзакции), иначе возможны гонки при одновременных операциях.

**Рекомендация:** Все изменения баланса — в одном сервисе, внутри транзакций БД с блокировкой строки пользователя; проценты — из конфига.

---

### 3.4 Споры и арбитраж

- **create_dispute:** проверяется, что пользователь — клиент заказа и заказ в статусе `completed` или `review`. Спор создаётся без явной привязки к создателю (связь через order).
- **resolve:** может вызвать любой с правами (admin или назначенный арбитр); результат пишется из `request.data.get('result')` без валидации длины и формата.

**Рекомендация:** В модели спора хранить создателя (например, `created_by`); при resolve — валидировать и ограничивать размер/формат `result`, логировать смену статуса и ответственного.

---

### 3.5 Права на просмотр заказа

- **OrderViewSet.get_queryset():** заказы отдаются, если пользователь — клиент, эксперт, или заказ в статусе `new` без эксперта. Так «новые» заказы видны всем авторизованным (для ленты это нужно, но список «мои заказы» на фронте должен строиться только по client_id/expert_id на бэкенде).
- Уже исправлено: «мои размещённые заказы» берутся из `client_orders` для любого пользователя, а не только при role=client.

---

## 4. Рекомендации по приоритетам

| Приоритет | Действие |
|-----------|----------|
| Критичный | Устранить IDOR в OrderFileViewSet: фильтровать файлы по заказам, доступным текущему пользователю (client/expert/staff). |
| Критичный | Обеспечить скачивание файлов заказа с учётом JWT (через фронт с токеном или одноразовая ссылка). |
| Критичный | Проверять SECRET_KEY и ALLOWED_HOSTS при старте в production; не хранить секреты в коде. |
| Высокий  | Вынести платёжный callback в отдельный AllowAny-endpoint с проверкой подписи. |
| Высокий  | Унифицировать проверки роли (getattr(user, 'role', None)) и обработку None. |
| Высокий  | В production не использовать CORS_ALLOW_ALL_ORIGINS; задавать CORS из env. |
| Средний  | Ограничить apply_discount/remove_discount только клиентом заказа (или политикой). |
| Средний  | Ввести единый слой переходов статусов заказа и явную матрицу допустимых переходов. |
| Средний  | Все операции с balance/frozen_balance выполнять в транзакциях с блокировкой (select_for_update). |

---

*Документ составлен по состоянию кодовой базы на момент анализа. При внесении изменений в auth, платежи, заказы и файлы имеет смысл обновить отчёт.*
