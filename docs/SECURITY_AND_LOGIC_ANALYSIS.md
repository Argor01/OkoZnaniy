# Аудит областей «Эксперт/Клиент» в проекте OkoZnaniy

Дата: 2026-02-20

## 0. Критерии аудита

### 0.1 Авторизация и сессии (Authentication)
- Токены/куки хранятся и передаются безопасно; минимизация XSS/CSRF рисков.
- Обработка истечения access token (UX и безопасность): refresh/выход/единая обработка 401.

### 0.2 Права доступа (Authorization: RBAC/ABAC)
- Любое действие проверяет роль и принадлежность объекта (order/chat/work/purchase).
- Есть object-level защита от IDOR: нельзя получить/изменить объект по чужому ID.
- Права формализованы матрицей: роль × действие × статус.

### 0.3 Данные и приватность
- Публичные профили не раскрывают чувствительные поля (email/телефон/балансы/рефералы).
- API не отдает лишние поля “по умолчанию”.

### 0.4 Ввод/вывод и контент (XSS/HTML)
- Любой HTML, который хранится/показывается, санитизируется.
- Фронт не рендерит недоверенный HTML напрямую.

### 0.5 Файлы (upload/download)
- Ограничения по типам/размеру/количеству.
- Скачивание защищено авторизацией, ссылки не становятся “public share”.

### 0.6 Платежи и callback/webhook
- Callback доступен провайдеру (`AllowAny`) и защищён подписью/секретом.
- Статус заказа меняется только после верификации платежа.

### 0.7 Качество кода и сопровождение
- Единообразие ролей/статусов/констант, отсутствие “строк‑магии”.
- Тесты на критичные сценарии (RBAC/IDOR/статусы/платежи).

## 0.8 Матрица риска

| Уровень | Что означает |
|--------|--------------|
| Critical | Компрометация денег/файлов/аккаунтов или массовая утечка данных |
| High | Существенный обход бизнес‑логики/частичная утечка/подмена данных |
| Medium | Ограниченная эксплуатация или требует условий |
| Low | Код‑смеллы, потенциальные баги/регрессии |

## Оглавление
1. [Архитектура и стек](#1-архитектура-и-стек)
2. [Уязвимости и риски безопасности](#2-уязвимости-и-риски-безопасности)
3. [Критичные моменты бизнес-логики](#3-критичные-моменты-бизнес-логики)
4. [Рекомендации по приоритетам](#4-рекомендации-по-приоритетам)

---

## 1. Архитектура и стек

- **Backend:** Django, DRF, SimpleJWT, PostgreSQL/SQLite, Redis, Celery, Channels.
- **Frontend:** React (Vite), axios, React Query.
- **Auth:** JWT (access/refresh), allauth (Google/VK), email/username backend.
- **Роли:** client, expert, arbitrator, admin, partner (модель `User.role`).

---

## 2. Уязвимости и риски безопасности

### 2.1 Критичные

#### Публичный профиль пользователя раскрывает чувствительные данные (PII/финансы)

**Где:** `apps/users/views.py` + `apps/users/serializers.py`.

**Статус:** ✅ сделано

**Риск:** по ID пользователя можно получить email/телефон/баланс/реферальные поля и т.д., т.к. `retrieve` открыт публично.

**Доказательства:**
- `AllowAny` для `retrieve`: [views.py:L62-L80](file:///c:/Users/omen/Desktop/Projects/OkoZnaniy/apps/users/views.py#L62-L80)
- Поля `UserSerializer` включают `email/phone/balance/...`: [serializers.py:L34-L52](file:///c:/Users/omen/Desktop/Projects/OkoZnaniy/apps/users/serializers.py#L34-L52)

**Рекомендация:**
- Для публичного профиля использовать отдельный сериализатор (пример уже есть: `SimpleUserSerializer`) или ограничить `retrieve` до `IsAuthenticated`.
- Считать публичными только безопасные поля (id/имя/аватар/верификация).

---

#### Логирование учетных данных при логине (пароль в логах/stdout)

**Где:** `apps/users/views.py` — `CustomTokenObtainPairView.post`.

**Статус:** ✅ сделано

**Риск:** в лог/STDOUT пишется `request.data` для login endpoint, что обычно содержит пароль. Это приводит к утечке паролей в журналы (файлы логов, APM, stdout контейнера), а дальше — к компрометации аккаунтов.

**Доказательство:**
- Логирование `request.data`: [views.py:L33-L40](file:///c:/Users/omen/Desktop/Projects/OkoZnaniy/apps/users/views.py#L33-L40)

**Рекомендация:**
- Немедленно убрать логирование `request.data` и `print(...)` из login endpoint.
- Если нужен аудит — логировать только безопасные поля (например, username/email в нормализованном виде) и только на уровне “успех/ошибка” без секретов.

---

#### Stored XSS в магазине работ через HTML-описание

**Где:** фронт `dangerouslySetInnerHTML` + редактор, сохраняющий `innerHTML` без санитизации.

**Статус:** ✅ сделано

**Риск:** автор работы может внедрить JS в `description`; при просмотре у других пользователей выполнится скрипт. При хранении JWT в `localStorage` это может привести к захвату аккаунта.

**Доказательства:**
- Рендер HTML без санитизации: [ShopWorkDetail.tsx:L326-L340](file:///c:/Users/omen/Desktop/Projects/OkoZnaniy/frontend-react/src/pages/ShopWorkDetail.tsx#L326-L340), [WorkCard/index.tsx:L75-L82](file:///c:/Users/omen/Desktop/Projects/OkoZnaniy/frontend-react/src/pages/ShopReadyWorks/components/WorkCard/index.tsx#L75-L82)
- Редактор записывает `innerHTML` напрямую: [RichTextEditor/index.tsx:L42-L60](file:///c:/Users/omen/Desktop/Projects/OkoZnaniy/frontend-react/src/components/editor/RichTextEditor/index.tsx#L42-L60)

**Рекомендация:**
- Ввести санитизацию HTML (предпочтительно на бэкенде) и/или хранить markdown/ограниченный формат.
- Не рендерить непроверенный HTML через `dangerouslySetInnerHTML`.
- Добавить CSP как “вторая линия обороны”.

---

#### Готовые работы: создание доступно любому авторизованному пользователю (роль не проверяется)

**Где:** `apps/shop/views.py` — `ReadyWorkViewSet.create`.

**Статус:** ✅ сделано

**Риск:** клиенты/партнеры могут загружать “готовые работы” и файлы, что ломает доменную модель и усиливает XSS/файловые риски.

**Доказательство:** роль не проверяется, достаточно `IsAuthenticated`: [views.py:L14-L76](file:///c:/Users/omen/Desktop/Projects/OkoZnaniy/apps/shop/views.py#L14-L76)

**Рекомендация:** ограничить `create/update/delete` для `role=expert` (и/или staff), зафиксировать матрицу прав по магазину.

---

#### Файлы заказа: IDOR (историческая запись — в коде сейчас закрыто)

**Где:** `apps/orders/views.py` — `OrderFileViewSet`.

**Статус:** в текущей версии код уже ограничивает доступ только участниками заказа (client/expert/staff), поэтому прямой сценарий IDOR для файлов заказа не воспроизводится.

**Доказательство:** проверка участия в заказе и фильтрация queryset: [views.py:L583-L598](file:///c:/Users/omen/Desktop/Projects/OkoZnaniy/apps/orders/views.py#L583-L598)

**Рекомендация:** Зафиксировать это как инвариант (тестами на object-level доступ) и убедиться, что ссылки на файлы нигде не отдаются напрямую (обходя `download`-endpoint).

---

#### Скачивание файла заказа без токена (401 при открытии ссылки)

**Где:** фронт отдаёт ссылку на `download_url`; пользователь может открыть её в новой вкладке или скопировать.

**Статус:** ✅ сделано

- Запрос к `download` идёт без заголовка `Authorization`, если ссылка открыта вне SPA.
- Сервер возвращает 401, файл не скачивается.

**Рекомендация:** Не использовать прямую ссылку для скачивания. На фронте: вызов API с токеном (например, `GET download` через `apiClient`), получение blob, создание временной ссылки и программное скачивание. Либо отдельный endpoint с одноразовым токеном в query для скачивания (с коротким TTL и привязкой к user/order).

---

#### Секреты и окружение

**Статус:** ✅ сделано

- **SECRET_KEY:** берётся из `os.getenv("SECRET_KEY")`. Если в проде переменная не задана, ключ будет `None` — возможны сбои и риски сессий/JWT.
- **ALLOWED_HOSTS:** из env. Пустая строка даёт `['']` — небезопасно для продакшена.
- В `settings.py` закомментирован старый SECRET_KEY — не оставлять в репозитории даже закомментированным.
- Платёжные пароли (ALFABANK_*, SBP_*) в коде как плейсхолдеры — в проде обязаны быть только в env.

**Рекомендация:** В проде всегда задавать SECRET_KEY и ALLOWED_HOSTS; при старте приложения проверять их наличие и выходить с ошибкой, если не заданы.

---

### 2.2 Высокий приоритет

#### CORS

- **Где:** `config/settings.py`
- В DEBUG: `CORS_ALLOW_ALL_ORIGINS = True` — любый origin может ходить к API.
- В production: `CORS_ALLOW_ALL_ORIGINS = False`, но в `CORS_ALLOWED_ORIGINS` указаны в т.ч. IP (например, `45.12.239.226`). Утечка домена/IP в репозитории.

**Рекомендация:** В проде не использовать `CORS_ALLOW_ALL_ORIGINS`; задавать только нужные фронт-домены через env (без хардкода IP в коде).

---

#### CSRF в DEBUG

- В `DEBUG=True` ослаблены настройки CSRF (cookie secure, httponly и т.д.). Для API на JWT это часто допустимо, но если где-то остались cookie-сессии для критичных действий — риск.

**Рекомендация:** Чётко разделять: только JWT для API; если используются cookie-сессии — не отключать CSRF для них и не ослаблять настройки в проде.

---

#### Платёжный callback (process_callback)

- **Где:** `apps/payments/views.py` — `PaymentViewSet.process_callback` (POST по `pk`).
- ViewSet под `permission_classes = [IsAuthenticated]`, `get_queryset()` ограничивает платежи по `order__client=user`.
- Callback от платёжного провайдера обычно идёт без JWT; при текущей схеме запрос от банка получит 401.

**Доказательства:**
- Auth-only callback: [views.py:L14-L24](file:///c:/Users/omen/Desktop/Projects/OkoZnaniy/apps/payments/views.py#L14-L24), [views.py:L77-L93](file:///c:/Users/omen/Desktop/Projects/OkoZnaniy/apps/payments/views.py#L77-L93)

**Дополнительный риск:** при успешном callback заказ принудительно переводится в `in_progress` без проверки текущего статуса и бизнес‑инвариантов (например, нельзя “оживить” отмененный заказ).

**Доказательство:** [services.py:L37-L57](file:///c:/Users/omen/Desktop/Projects/OkoZnaniy/apps/payments/services.py#L37-L57)

**Рекомендация:**
- Вынести обработку callback в отдельный endpoint (например, `POST /api/payments/callback/`), с `AllowAny`, проверкой подписи/секрета от провайдера и без привязки к текущему пользователю.
- Делать переход статуса заказа через единую машину состояний/сервис с проверкой “разрешенных переходов” и идемпотентностью.

---

#### Роль пользователя: непоследовательные проверки

- В части мест используется `user.role` (например, `orders/views.py`: `take_order`, `create_dispute`), в других — `getattr(user, 'role', None)`.
- При отсутствии поля или миграции возможен `AttributeError` в первых случаях.

**Рекомендация:** Везде использовать безопасное получение роли (например, `getattr(user, 'role', None)`) и явно обрабатывать `None` (отказ в доступе или дефолтная роль).

---

#### Заказы: доступ к “новым” заказам выдан всем авторизованным (риск утечки данных)

**Где:** `apps/orders/views.py` — `OrderViewSet.get_queryset`.

**Риск:** любой авторизованный пользователь видит все заказы со статусом `new` без назначенного эксперта. Если в заказах есть персональные данные (телефон/контакты/описание “с деталями”), это становится утечкой.

**Доказательство:** фильтр включает `status='new', expert__isnull=True`: [views.py:L26-L41](file:///c:/Users/omen/Desktop/Projects/OkoZnaniy/apps/orders/views.py#L26-L41)

**Рекомендация:** отделить “ленточные” данные от “карточки заказа”:
- В `available` возвращать только безопасный набор полей (без PII) через отдельный сериализатор.
- `retrieve` ограничить участниками заказа (client/expert/staff), если карточка содержит чувствительные детали.

---

#### Заказы: скидки можно применять/снимать без явной проверки прав (влияние на цену)

**Где:** `apps/orders/views.py` — `OrderViewSet.apply_discount/remove_discount`.

**Риск:** любой пользователь, который прошел object-level фильтрацию `get_object()` (клиент, эксперт, staff), может изменять скидку и итоговую стоимость заказа. Если по политике скидку должен менять только клиент (или система), это нарушение доменной модели и финансовый риск.

**Доказательство:** отсутствие проверки `order.client_id == request.user.id`/роли в action: [views.py:L332-L368](file:///c:/Users/omen/Desktop/Projects/OkoZnaniy/apps/orders/views.py#L332-L368)

**Рекомендация:** явно ограничить вызов (обычно `order.client` и staff) и дополнительно запретить изменения после перехода в работу/после оплаты.

---

#### Магазин: delivered_file_url отдается как прямой URL к storage (риск публичного доступа)

**Где:** `apps/shop/serializers.py` — `PurchaseSerializer.get_delivered_file_url`.

**Риск:** если `MEDIA_URL`/storage настроены как публичные, любой обладатель ссылки сможет скачать “доставленный файл” покупки без авторизации, обходя логику “только покупатель”.

**Доказательство:** возвращается `obj.delivered_file.url`/`build_absolute_uri(...)`: [serializers.py:L112-L141](file:///c:/Users/omen/Desktop/Projects/OkoZnaniy/apps/shop/serializers.py#L112-L141)

**Рекомендация:** выдавать файл через защищенный endpoint с object-level проверкой (buyer==request.user), а не прямым URL.

---

#### Эксперты: статистика/документы раскрывают финансовые и PII-поля через вложенный UserSerializer

**Где:** `apps/experts/views.py`, `apps/experts/serializers.py`, `apps/users/serializers.py`.

**Риск:**
- `ExpertStatisticsViewSet` для “обычных пользователей” возвращает статистику без ограничения по владельцу. При `?expert=<id>` любой авторизованный может получить статистику любого эксперта, включая `total_earnings` (финансовые данные).
- В нескольких сериализаторах экспертов используется “полный” `UserSerializer`, который содержит email/phone/balance и др. поля. Это приводит к избыточной выдаче данных в ответах экспертовских endpoint-ов (даже если исходный сценарий “публичный”).

**Доказательства:**
- Статистика не режется для не-expert пользователей: [experts/views.py:L189-L227](file:///c:/Users/omen/Desktop/Projects/OkoZnaniy/apps/experts/views.py#L189-L227)
- Состав полей статистики включает `total_earnings`: [experts/serializers.py:L137-L151](file:///c:/Users/omen/Desktop/Projects/OkoZnaniy/apps/experts/serializers.py#L137-L151)
- Документы экспертов доступны любому авторизованному (is_verified=True): [experts/views.py:L79-L91](file:///c:/Users/omen/Desktop/Projects/OkoZnaniy/apps/experts/views.py#L79-L91)
- Вложенный `UserSerializer` у экспертов: [experts/serializers.py:L30-L42](file:///c:/Users/omen/Desktop/Projects/OkoZnaniy/apps/experts/serializers.py#L30-L42)
- `UserSerializer` содержит чувствительные поля (email/phone/balance/...): [users/serializers.py:L34-L52](file:///c:/Users/omen/Desktop/Projects/OkoZnaniy/apps/users/serializers.py#L34-L52)

**Рекомендация:**
- Для “публичных” ответов использовать `SimpleUserSerializer` (без email/phone/balance) и отдельные сериализаторы для статистики/документов.
- Ограничить доступ к `total_earnings` (например, только staff и сам эксперт). Для клиентов — выдавать агрегаты без денег или только “успешность/рейтинг”.
- Для verified документов решить политику: либо доступ только staff/сам эксперт, либо отдавать только метаданные без `file_url`, либо выдавать файлы через защищенный download endpoint.

### 2.3 Средний приоритет

#### Загрузка файлов (чаты, заказы)

- Размер и расширения проверяются (ALLOWED_EXTENSIONS, MAX_UPLOAD_SIZE).
- Нет проверки содержимого (тип по magic bytes); теоретически возможна загрузка подменённого «документа» с опасным содержимым.

**Рекомендация:** Хранить файлы вне корня раздачи; отдавать через контролируемый view (как сейчас); при необходимости — проверка MIME по содержимому и лимит количества/размера вложений на пользователя.

#### Магазин работ: загрузка файлов без явных ограничений по типу/размеру

**Где:** `apps/shop/views.py` — `ReadyWorkViewSet.create`.

- Файлы берутся из `request.FILES.getlist('work_files')` и сохраняются как есть.
- Нет валидации расширений/типа/размера и лимитов по количеству файлов на работу.

**Доказательство:** [views.py:L53-L76](file:///c:/Users/omen/Desktop/Projects/OkoZnaniy/apps/shop/views.py#L53-L76)

**Рекомендация:** ввести ограничения (разрешенные расширения, max size, max count), при необходимости проверку MIME по содержимому, и разнести публичные/приватные файлы.

---

#### Индивидуальные предложения в чате: недостаточно строгая привязка “кто именно может принять”

**Где:** `apps/chat/views.py` — `accept_offer`.

- Нет явной проверки `role=client` для принимающего (проверяется в основном через `chat.client_id`).
- При нестандартной конфигурации участников чата (например, добавление staff/support в participants) возможны неожиданные права на принятие предложения.
- При принятии предложения создается заказ со статусом `in_progress` напрямую и бюджетом из `offer_data['cost']` без явной валидации (в т.ч. на отрицательные/аномальные значения).

**Доказательство:** [views.py:L496-L590](file:///c:/Users/omen/Desktop/Projects/OkoZnaniy/apps/chat/views.py#L496-L590)

**Рекомендация:**
- Явно требовать `chat.client == request.user` (или роль client + владение), не полагаясь на состав participants.
- Вынести `offer_data` в сериализатор/схему и валидировать поля (cost>=0, deadline, обязательные поля).
- Делать создание заказа через доменный сервис, который контролирует допустимый статус и сценарий оплаты.

---

#### Чат: запрет контактов в тексте

- В модели `Message.clean()` запрещаются подстроки вроде телефонов, @, url. Обход возможен (пробелы, юникод, разбиение).

**Рекомендация:** Считать текущую проверку базовой; при ужесточении политики — нормализация строк и более строгие правила/модерация.

---

#### JWT и хранение на фронте

- Токен в `localStorage` — уязвим при XSS. Для SPA это распространённая схема, но риск есть.

**Рекомендация:** Строгая санитизация вывода, Content-Security-Policy; при высокой чувствительности — рассмотреть httpOnly cookie для refresh и короткоживущий access в памяти.

---

#### Frontend: доступ к разделам проверяется только наличием access_token

**Где:** `frontend-react/src/components/ProtectedRoute.tsx`.

**Риск:** это не “уязвимость бэкенда”, но UX/безопасность по краю: доступ к странице выдается по наличию строки в `localStorage`, без проверки роли/валидности токена. В результате пользователь с протухшим/поддельным токеном попадает в UI и получает каскад 401/403 от API.

**Доказательство:** [ProtectedRoute.tsx:L8-L16](file:///c:/Users/omen/Desktop/Projects/OkoZnaniy/frontend-react/src/components/ProtectedRoute.tsx#L8-L16)

**Рекомендация:** держать права на стороне API (как основную защиту), а на фронте:
- опционально добавить role-guards для маршрутов, используя данные “me” с сервера,
- централизованно обрабатывать 401/refresh (у вас уже есть логика в `api/client.ts`).

---

#### Frontend: GoogleCallback доверяет role/user из URL‑параметров

**Где:** `frontend-react/src/pages/GoogleCallback.tsx`.

**Риск:** роль и user-объект в `localStorage` выставляются из query string. Если где-то в UI есть доверие к `localStorage.user.role` (например, скрытие/показ действий), это можно подменить на клиенте. Бэкенд это не ломает при корректной RBAC, но повышает риск UI-багов и вводит “ложные” проверки доступа.

**Доказательство:** запись `role` из URL в `localStorage`: [GoogleCallback.tsx:L23-L46](file:///c:/Users/omen/Desktop/Projects/OkoZnaniy/frontend-react/src/pages/GoogleCallback.tsx#L23-L46)

**Рекомендация:** после получения токенов всегда запрашивать `/me` (или аналог) и заполнять user из ответа сервера, а роль из URL использовать только для временного редиректа (или вообще не использовать).

---

#### Frontend: “директор” определяется по хардкоду email

**Где:** `frontend-react/src/utils/roleRedirect.ts`.

**Риск:** хардкод `director@test.com` — это источник ошибок и “магическая” логика доступа в клиенте. Не является защитой (бэкенд обязан проверять права), но может вести к неправильным редиректам/UX и усложняет сопровождение.

**Доказательство:** [roleRedirect.ts:L14-L20](file:///c:/Users/omen/Desktop/Projects/OkoZnaniy/frontend-react/src/utils/roleRedirect.ts#L14-L20)

**Рекомендация:** признак “director” должен приходить от API (роль/claim), без email-эвристик на фронте.

---

## 3. Критичные моменты бизнес-логики

### 3.1 Заказы и статусы

- Переходы статусов разбросаны по разным action (`approve`, `revision`, `submit`, `complete`, `take` и т.д.). Нет единой машины состояний (например, явной матрицы «кто и из какого статуса может перевести в какой»).
- **take_order** (стр. ~273): проверяется `order.status == 'new'`, но в других местах есть переходы из `waiting_payment`, `revision` — возможна рассинхронизация, если где-то забыли обновить условие.
- **complete_order** (стр. ~297): переводит заказ в `completed` без проверки оплаты. Если в системе есть сценарий «сначала оплата, потом завершение», возможен переход в «выполнен» до фактической оплаты.

**Рекомендация:** Вынести переходы статусов в один слой (сервис/машина состояний) с явной матрицей (текущий статус, роль, целевой статус) и единой точкой вызова.

---

### 3.2 Скидки на заказ

- **Где:** `OrderViewSet.apply_discount`, `remove_discount`.
- Нет явной проверки роли: любой, кто может вызвать `get_object()` для заказа (клиент, эксперт, staff), может применить или снять скидку.
- Эксперт может менять скидку по заказу клиента — вопрос политики (часто скидку должен менять только клиент или система).

**Рекомендация:** Явно ограничить вызов: например, только `order.client == request.user` или staff; при необходимости — только до определённого статуса (например, до «в работе»).

---

### 3.3 Деньги и балансы

- В коде встречаются фиксированные коэффициенты (например, 70% эксперту, 30% платформе) в `director/views.py`. Желательно вынести в настройки/константы и учитывать при расчётах выплат.
- Баланс и frozen_balance в модели User; списание/начисление должны быть атомарными (select_for_update или транзакции), иначе возможны гонки при одновременных операциях.

**Рекомендация:** Все изменения баланса — в одном сервисе, внутри транзакций БД с блокировкой строки пользователя; проценты — из конфига.

---

### 3.4 Споры и арбитраж

- **create_dispute:** проверяется, что пользователь — клиент заказа и заказ в статусе `completed` или `review`. Спор создаётся без явной привязки к создателю (связь через order).
- **resolve:** может вызвать любой с правами (admin или назначенный арбитр); результат пишется из `request.data.get('result')` без валидации длины и формата.

**Рекомендация:** В модели спора хранить создателя (например, `created_by`); при resolve — валидировать и ограничивать размер/формат `result`, логировать смену статуса и ответственного.

---

### 3.5 Права на просмотр заказа

- **OrderViewSet.get_queryset():** заказы отдаются, если пользователь — клиент, эксперт, или заказ в статусе `new` без эксперта. Так «новые» заказы видны всем авторизованным (для ленты это нужно, но список «мои заказы» на фронте должен строиться только по client_id/expert_id на бэкенде).
- Уже исправлено: «мои размещённые заказы» берутся из `client_orders` для любого пользователя, а не только при role=client.

---

## 4. Рекомендации по приоритетам

| Приоритет | Действие |
|-----------|----------|
| Критичный | Закрыть публичный `retrieve` профиля или убрать чувствительные поля из ответа. |
| Критичный | Убрать логирование `request.data` на login endpoint (пароли в логах/stdout). |
| Критичный | Устранить stored XSS: санитизация описаний работ и запрет сырого HTML. |
| Критичный | Ограничить создание/редактирование готовых работ по ролям (только expert/staff). |
| Высокий  | Сделать платежный callback: отдельный `AllowAny` endpoint + проверка подписи + идемпотентность. |
| Высокий  | Ограничить видимость “new без эксперта” заказов или санитизировать выдачу в ленте. |
| Высокий  | Убрать прямые URL приватных файлов покупок (delivered_file_url) в пользу download endpoint. |
| Высокий  | Закрыть утечку в experts endpoint-ах (stats/docs/user поля, total_earnings). |
| Высокий  | Обеспечить скачивание файлов заказа с JWT (blob‑download/one‑time link). |
| Высокий  | Ограничить apply_discount/remove_discount по политике (обычно только client/staff). |
| Средний  | Унифицировать проверки роли и обработку `None` (единый helper, без `AttributeError`). |
| Средний  | Ввести единый слой переходов статусов заказа и матрицу допустимых переходов. |
| Средний  | В production не использовать `CORS_ALLOW_ALL_ORIGINS`; задавать CORS из env. |
| Средний  | Операции с `balance/frozen_balance` делать в транзакциях с блокировкой строк. |
| Низкий   | Привести фронтовые role-редиректы к данным от API, без хардкода email. |

---

*Документ составлен по состоянию кодовой базы на момент анализа. При внесении изменений в auth, платежи, заказы и файлы имеет смысл обновить отчёт.*
